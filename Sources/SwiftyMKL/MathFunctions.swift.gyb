import Foundation
import CMKL
import CIPP

%{ import sys; sys.path.append('../..'); from funcs import * }%

%{
funcs1 = (('pow','Foundation'), ('min', 'Swift'), ('max', 'Swift'))
funcs2 = """acos acosh asin asinh atan atanh cbrt cos cosh erf erfc exp exp2 expm1 j0 j1 log log10 log1p log2 logb
nearbyint rint sin sinh tan tanh tgamma y0 y1""".split()
funcs3 = "atan2 copysign fdim fmax fmin hypot nextafter".split()
}%

public protocol SupportsMKL:BinaryFloatingPoint {
  typealias T=Self
  typealias PtrT = UnsafePointer<T>
  typealias MutPtrT = UnsafeMutablePointer<T>

  init(_ value: CGFloat)
  init(_ value: Self)
  init()
  var cgfloat : CGFloat {get}
% for f,_ in funcs1:
  func ${f}(_ b: Self) -> Self
% end # f
% for f in funcs2:
  func ${f}() -> Self
% end # f

% for f in mkl_lines:
  static func ${get_decl(f, mkl_re)}
% end

% for f in vml_lines:
  static func ${get_decl(f, vml_re)}
% end

% for f in ipp_lines:
  static func ${get_decl(f, ipp_re)}
% end
}

% for t,l,n in typ_typs:
extension ${t} : SupportsMKL {
  public var cgfloat : CGFloat { return CGFloat(self) }

  % for f,s in funcs1:
  public func ${f}(_ b: ${t}) -> ${t} {return ${s}.${f}(self, b)}
  % end # f,s

  % for f in mkl_lines:
  public static func ${get_decl(f, mkl_re)} { ${get_mkl_impl(f,t)} }
  % end

  % for f in vml_lines:
  public static func ${get_decl(f, vml_re)} { ${get_vml_impl(f,t)} }
  % end

  % for f in ipp_lines:
  public static func ${get_decl(f, ipp_re)} { ${get_ipp_impl(f,t)} }
  % end
}
% end # t

extension SupportsMKL {
  % for f in funcs2:
  public func ${f}() -> Self {return .init(Foundation.${f}(cgfloat))}
  % end # f

  % for f in funcs3:
  public func ${f}(_ b: Self) -> Self {return .init(Foundation.${f}(cgfloat, b.cgfloat))}
  % end # f
}

precedencegroup ExponentiationPrecedence { associativity: right higherThan: MultiplicationPrecedence }
infix operator ^^: ExponentiationPrecedence

public func ^^<T:SupportsMKL> (base:T, power:T) -> T {
  return base.pow(power)
}

