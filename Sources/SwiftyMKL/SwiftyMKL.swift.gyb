import Foundation
import CMKL
import CIPP

public func defaultValue<T>() -> T {
  let ptr = UnsafeMutablePointer<T>.allocate(capacity:1)
  let retval = ptr.pointee
  ptr.deallocate()
  return retval;
}

%{
def lower_split(s): return [(o, o[:1].lower() + o[1:]) for o in s.split()]
# vml (Vector)->Vector
vml1 = lower_split("""Ln Abs Inv Sqr Exp Cos Sin Tan Erf Sqrt Cbrt Cosh Sinh Tanh Acos Asin Atan Erfc Ceil Rint Expm1 Log10 Log1p
  Acosh Asinh Atanh Floor Round Trunc ErfInv Pow3o2 Pow2o3 InvSqrt InvCbrt NearbyInt """)
# ipp (Vector)->T
ipp1 = lower_split("Sum Mean StdDev Max Min")
# vml (Vector,Vector)->Vector
vml2 = lower_split("Add Sub Mul Div Pow Hypot Atan2")
# ipp (Vector,Scalar)->Vector
ipp2 = lower_split("Add Sub Mul Div")
# ipp (Vector,Vector)->Scalar
ipp3 = lower_split("NormDiff_Inf NormDiff_L1 NormDiff_L2")
}%

extension Vector {
  public var p:MutPtrT {get {return data.p}}
  public var description: String { return "V\(Array(data).description)" }
  public init(_ data:Array<Scalar>) {self.init(ArrayStorage<Scalar>(data))}
  public init(_ count:Int) {self.init(ArrayStorage<Scalar>(count))}
  public var alignment:Int {return data.alignment}

  // IPP convenience functions
  typealias ippFuncReduceHint = (PtrT,Int32,MutPtrT,IppHintAlgorithm)->IppStatus
  typealias ippFuncReduce = (PtrT,Int32,MutPtrT)->IppStatus
  func ipp_reduce(_ f:(MutPtrT)->IppStatus)->Scalar {
    var res:Scalar=defaultValue(); let _=f(&res); return res
  }
  func ipp_reduce(_ f:ippFuncReduceHint)->Scalar { return ipp_reduce({f(p, c, $0, ippAlgHintFast)}) }
  func ipp_reduce(_ f:ippFuncReduce    )->Scalar { return ipp_reduce({f(p, c, $0)}) }

  public func new(_ size:Int)  -> Self { return Self.init(ArrayStorage<Scalar>(size,  alignment:alignment)) }
  public func new()  -> Self { return new(data.count) }
  public func copy() -> Self { return Self.init(ArrayStorage<Scalar>(Array(data), alignment:alignment)) }

  func new_call(_ f:(Self)         ->()              )->Self { let res = new(); f(res);    return res }
  func new_call(_ f:(Self, Self)   ->(), _ b:Self    )->Self { let res = new(); f(b, res); return res }
  func new_call<T>(_ f:(T, Self)   ->(), _ b:T       )->Self { let res = new(); f(b, res); return res }
  func new_call<T>(_ f:(T, T, Self)->(), _ b:T, _ c:T)->Self { let res = new(); f(b, c, res); return res }

  func new_call<T>(_ f:(T, Self)->(), _ b:T, n:Int)->Self { let res = new(n); f(b, res); return res }
  func new_call<T>(_ f:(T, T, Self)->(), _ b:T, _ c:T, n:Int)->Self { let res = new(n); f(b, c, res); return res }
}

% for t,l,n in (('Float', 's', '32'), ('Double', 'd', '64')):
public struct Vector${t}: Vector {
  public typealias Scalar=${t}
  public var data:ArrayStorage<${t}>
  public init(_ data_:ArrayStorage<${t}>) {data=data_}
}
% end # for t,l,n

% for t,l,n in (('Float', 's', '32'), ('Double', 'd', '64')):
extension Vector where Scalar==${t} {
  public func asum()->Scalar { return cblas_${l}asum(c, p, 1) }
  public func nrm2()->Scalar { return cblas_${l}nrm2(c, p, 1) }
  public func dot(_ b:Self)->Scalar { return cblas_${l}dot(c, p, 1, b.p, 1) }
  public func set(_ b: Scalar) { ippsSet_${n}f(b, p, c) }
  public func zero() { ippsZero_${n}f(p, c) }
  public func move(_ b:Self, _ n:Int) { ippsMove_${n}f(p, b.p, numericCast(n)) }
  public func move(_ b:Self, _ n:Int, fromIdx:Int, toIdx:Int) { ippsMove_${n}f(p+fromIdx, b.p+toIdx, numericCast(n)) }

/*
vsPackI,(const MKL_INT n,  const float  a[], const MKL_INT   incra, float  y[]))
vsPackV,(const MKL_INT n,  const float  a[], const MKL_INT ia[], float  y[]))
vsPackM,(const MKL_INT n,  const float  a[], const MKL_INT ma[], float  y[]))
*/
  public func packIncrement(_ incr:Int, _ n:Int, _ dest:Self) { v${l}PackI(numericCast(n), p, numericCast(incr), dest.p) }
  public func packIncrement(_ incr:Int, _ n:Int)->Self { return new_call(packIncrement, incr, n, n:n) }
  public func packIndices(_ idxs:[Int32], _ dest:Self) { v${l}PackV(numericCast(idxs.count), p, idxs, dest.p) }
  public func packIndices(_ idxs:[Int32])->Self { return new_call(packIndices, idxs, n:idxs.count) }
  public func packMasked(_ mask:[Int32], _ dest:Self) { v${l}PackM(c, p, mask, dest.p) }
  public func packMasked(_ mask:[Int32])->Self { return new_call(packMasked, mask, n:mask.count) }

  % for u,o in vml1:
  public func ${o}(_ dest: Self) { v${l}${u}(c, p, dest.p) }
  public func ${o}_() { ${o}(self) }
  public func ${o}() -> Self  { return new_call(${o}) }
  % end # vml1

  % for u,o in ipp1:
  public func ${o}()->Scalar { return ipp_reduce(ipps${u}_${n}f) }
  % end # ipp1

  % for u,o in vml2:
  public func ${o}(_ b:Self, _ dest:Self) { v${l}${u}(c, p, b.p, dest.p) }
  public func ${o}_(_ b:Self) { ${o}(b, self) }
  public func ${o}(_ b:Self)->Self { return new_call(${o}, b) }
  % end # vml2

  public func powx(_ b:Scalar, _ dest:Self) { v${l}Powx(c, p, b, dest.p) }
  public func powx_(_ b:Scalar) { powx(b, self) }
  public func powx(_ b:Scalar)->Self { return new_call(powx, b) }

  % for u,o in ipp2:
  public func ${o}(_ b:Scalar, _ dest:Self) { ipps${u}C_${n}f(p, b, dest.p, c) }
  public func ${o}_(_ b:Scalar) { ${o}(b, self) }
  public func ${o}(_ b:Scalar)->Self { return new_call(${o}, b) }
  % end # ipp2

  % for u,o in ipp3:
  public func ${o}(_ b:Self)->Scalar {return ipp_reduce({ipps${u}_${n}f(p, b.p, c, $0)})}
  % end # ipp3

  % for op,f in zip('+-*/', 'add sub mul div'.split()):
  public static func ${op}  (lhs:Self, rhs:Self  ) -> Self { return lhs.${f}( rhs) }
  public static func ${op}  (lhs:Self, rhs:Scalar) -> Self { return lhs.${f}( rhs) }
  public static func ${op}= (lhs:Self, rhs:Self  )         { return lhs.${f}_(rhs) }
  public static func ${op}= (lhs:Self, rhs:Scalar)         { return lhs.${f}_(rhs) }
  % end # op,f
  public static func + (lhs:Scalar, rhs:Self) -> Self { return rhs.add(lhs) }
  public static func * (lhs:Scalar, rhs:Self) -> Self { return rhs.mul(lhs) }
}
% end

