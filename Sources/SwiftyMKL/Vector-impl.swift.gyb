import Foundation
import CSwiftyMKL
import CIPL

%{
import sys; sys.path.append('../..');
from funcs import *
all_lines = sm_lines+cblas_lines+vml_lines+ipps_lines+rng_lines
all_h = [MklHeader(o) for o in all_lines]
}%

extension Vector {
% for h in all_h:
  ${h.impl_all_inst()}
% end

  func new_call(_ f:(Self)         ->()              )->Self { let res = new(); f(      res); return res }
  func new_call(_ f:(Self, Self)   ->(), _ b:Self    )->Self { let res = new(); f(b,    res); return res }
  func new_call<T>(_ f:(T, Self)   ->(), _ b:T       )->Self { let res = new(); f(b,    res); return res }
  func new_call<T>(_ f:(T, T, Self)->(), _ b:T, _ c:T)->Self { let res = new(); f(b, c, res); return res }

  func new_call<T>(_ f:(T, Self)->(), _ b:T, n:Int)->Self { let res = new(n); f(b, res); return res }
  func new_call<T>(_ f:(T, T, Self)->(), _ b:T, _ c:T, n:Int)->Self { let res = new(n); f(b, c, res); return res }

  public func asum()->Element { return asum(1) }
  public func nrm2()->Element { return nrm2(1) }
  public func dot(_ b:Self)->Element { return dot(1, b, 1) }
  public func set(_ b: Element) { set(b,self) }
  public func zero() { zero(self) }
  public func move(_ b:Self, _ n:Int) { Element.move(p, b.p, n) }
  public func move(_ b:Self, _ n:Int, fromIdx:Int, toIdx:Int) { Element.move(p+fromIdx, b.p+toIdx, n) }

  % for o in map(lower1,vml1):
  public func ${o}_() { ${o}(self) }
  public func ${o}() -> Self  { return new_call(${o}) }
  % end # vml1

  % for o in map(lower1,vml2):
  public func ${o}_(_ b:Self) { ${o}(b, self) }
  public func ${o}(_ b:Self)->Self { return new_call(${o}, b) }
  % end # vml2

  % for o in map(lower1,ipp2):
  public func ${o}_(_ b:Element) { ${o}(b, self) }
  public func ${o}(_ b:Element)->Self { return new_call(${o}, b) }
  % end # ipp2

  func ipp_reduce(_ f:(Self)->())->Element { let res = Self.init(1); f(res); return res[0] }

  % for o in map(lower1,ipp1):
  public func ${o}()->Element { return ipp_reduce(${o}) }
  % end # ipp1

  % for o in map(lower1,ipp3):
  public func ${o}(_ b:Self)->Element {return ipp_reduce({${o}(b, $0)})}
  % end # ipp3

  public func powx_(_ b:Element) { powx(b, self) }
  public func powx(_ b:Element)->Self { return new_call(powx, b) }

  % for op,f in zip('+-*/', 'add sub mul div'.split()):
  public static func ${op}  (lhs:Self, rhs:Self   ) -> Self { return lhs.${f}(  rhs) }
  public static func ${op}  (lhs:Self, rhs:Element) -> Self { return lhs.${f}C( rhs) }
  public static func ${op}= (lhs:Self, rhs:Self   )         {        lhs.${f}_( rhs) }
  public static func ${op}= (lhs:Self, rhs:Element)         {        lhs.${f}C_(rhs) }
  % end # op,f
  % for op,f in zip('+-*/', 'addC subCRev mulC divCRev'.split()):
  public static func ${op}  (lhs:Element, rhs:Self) -> Self { return rhs.${f}(  lhs) }
  % end # op,f

  public func packIncrement(_ incr:Int, _ from:Int, _ n:Int, _ dest:Self) { Element.packI(n, p+from, incr, dest.p) }
  public func packIncrement(_ incr:Int, _ from:Int, _ n:Int)->Self {
    let res = new(n); packIncrement(incr, from, n, res); return res
  }
  public func packIndices(_ idxs:[Int32], _ dest:Self) { Element.packV(idxs.count, p, idxs, dest.p) }
  public func packMasked( _ mask:[Int32], _ dest:Self) { Element.packM(mask.count, p, mask, dest.p) }
  public func packIndices(_ idxs:[Int32])->Self { return new_call(packIndices, idxs, n:idxs.count) }
  public func packMasked( _ mask:[Int32])->Self { return new_call(packMasked,  mask, n:Int(mask.reduce(0,+))) }
}

/*
// Currently unused
% for op,p in zip('+-*/', ['AdditionPrecedence']*2 + ['MultiplicationPrecedence']*2):
infix operator .${op}:  ${p}
infix operator .${op}=: AssignmentPrecedence
% end
*/

