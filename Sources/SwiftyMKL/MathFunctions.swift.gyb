import Foundation

%{
funcs1 = (('pow','Foundation'), ('min', 'Swift'), ('max', 'Swift'))
funcs2 = """acos acosh asin asinh atan atanh cbrt cos cosh erf erfc exp exp2 expm1 j0 j1 log log10 log1p log2 logb
nearbyint rint sin sinh tan tanh tgamma y0 y1""".split()
funcs3 = "atan2 copysign fdim fmax fmin hypot nextafter".split()
}%

public protocol SupportsMKL:BinaryFloatingPoint {
  init(_ value: CGFloat)
  init()
  var cgfloat : CGFloat {get}
  static var zero:Self {get}
  static var one:Self {get}
  static var two:Self {get}
% for f,_ in funcs1:
  func ${f}(_ b: Self) -> Self
% end # f
% for f in funcs2:
  func ${f}() -> Self
% end # f
}

% for t in ('Float', 'Double'):
extension ${t} : SupportsMKL {
  public var cgfloat : CGFloat { return CGFloat(self) }
  public static var one:${t} {get {return 1}}
  public static var two:${t} {get {return 2}}

  % for f,s in funcs1:
  public func ${f}(_ b: ${t}) -> ${t} {return ${s}.${f}(self, b)}
  % end # f,s
}
% end # t

extension SupportsMKL {
  public static var zero:Self {get {return .init()}}

  % for f in funcs2:
  public func ${f}() -> Self {return .init(Foundation.${f}(cgfloat))}
  % end # f

  % for f in funcs3:
  public func ${f}(_ b: Self) -> Self {return .init(Foundation.${f}(cgfloat, b.cgfloat))}
  % end # f
}

precedencegroup ExponentiationPrecedence { associativity: right higherThan: MultiplicationPrecedence }
infix operator ^^: ExponentiationPrecedence

public func ^^<T:SupportsMKL> (base:T, power:T) -> T {
  return base.pow(power)
}

